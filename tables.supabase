create table public.brands (
  id bigint generated by default as identity not null,
  owner_id uuid not null,
  brand_name text not null,
  avatar_url text null,
  created_at timestamp with time zone null default timezone ('utc'::text, now()),
  description text null,
  image_url text null,
  default_commission_rate numeric(5, 2) null,
  constraint brands_pkey primary key (id),
  constraint brands_owner_id_fkey foreign KEY (owner_id) references auth.users (id) on delete CASCADE,
  constraint brands_default_commission_rate_check check (
    (
      (default_commission_rate is null)
      or (
        (default_commission_rate >= (0)::numeric)
        and (default_commission_rate <= (100)::numeric)
      )
    )
  )
) TABLESPACE pg_default;

create unique INDEX IF not exists brands_owner_id_brand_name_key on public.brands using btree (
  owner_id,
  lower(
    TRIM(
      both
      from
        brand_name
    )
  )
) TABLESPACE pg_default
where
  (
    (brand_name is not null)
    and (
      TRIM(
        both
        from
          brand_name
      ) <> ''::text
    )
  );

  create table public.showrooms (
  id bigint generated by default as identity not null,
  owner_id uuid not null,
  name text not null,
  address text null,
  city text null,
  code_postal text null,
  description text null,
  image_url text null,
  default_commission_rate integer null default 20,
  vibe_tags text[] null,
  traffic_level text null,
  instagram_handle text null,
  is_verified boolean null default false,
  is_permanent boolean null default true,
  start_date date null,
  end_date date null,
  publication_status text not null default 'draft'::text,
  constraint showrooms_pkey primary key (id),
  constraint showrooms_owner_id_fkey foreign KEY (owner_id) references auth.users (id) on delete CASCADE,
  constraint showrooms_publication_status_check check (
    (
      publication_status = any (array['draft'::text, 'published'::text])
    )
  )
) TABLESPACE pg_default;

create table public.products (
  id bigint generated by default as identity not null,
  brand_id bigint not null,
  product_name text not null,
  price numeric not null,
  description text null,
  image_url text null,
  commission_percent numeric(5, 2) null,
  stock_max integer null default 0,
  created_at timestamp with time zone null default timezone ('utc'::text, now()),
  constraint products_pkey primary key (id),
  constraint products_brand_id_fkey foreign KEY (brand_id) references brands (id) on delete CASCADE,
  constraint products_commission_percent_check check (
    (
      (commission_percent >= (0)::numeric)
      and (commission_percent <= (100)::numeric)
    )
  ),
  constraint products_stock_max_check check ((stock_max >= 0))
) TABLESPACE pg_default;

create table public.placements (
  id uuid not null default gen_random_uuid (),
  product_id bigint not null,
  showroom_id bigint not null,
  status text null default 'pending'::text,
  agreed_commission_rate integer null,
  stock_quantity integer null default 1,
  initiated_by text null default 'brand'::text,
  created_at timestamp with time zone null default timezone ('utc'::text, now()),
  constraint placements_pkey primary key (id),
  constraint placements_initiated_by_check check (initiated_by is null or initiated_by in ('brand', 'showroom')),
  constraint placements_product_id_fkey foreign KEY (product_id) references products (id) on delete CASCADE,
  constraint placements_showroom_id_fkey foreign KEY (showroom_id) references showrooms (id) on delete CASCADE,
  constraint placements_status_check check (
    (
      status = any (
        array[
          'pending'::text,
          'active'::text,
          'sold'::text,
          'returned'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists placements_product_id_idx on public.placements using btree (product_id) TABLESPACE pg_default;

create index IF not exists placements_showroom_id_idx on public.placements using btree (showroom_id) TABLESPACE pg_default;

create index IF not exists placements_status_idx on public.placements using btree (status) TABLESPACE pg_default;

create trigger placements_updated_at BEFORE
update on placements for EACH row
execute FUNCTION set_placements_updated_at ();

create table public.placement_messages (
  id uuid not null default gen_random_uuid (),
  placement_id uuid not null,
  sender_id uuid not null,
  body text not null,
  created_at timestamp with time zone null default now(),
  constraint placement_messages_pkey primary key (id),
  constraint placement_messages_placement_id_fkey foreign KEY (placement_id) references placements (id) on delete CASCADE,
  constraint placement_messages_sender_id_fkey foreign KEY (sender_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists placement_messages_placement_id_idx on public.placement_messages using btree (placement_id) TABLESPACE pg_default;